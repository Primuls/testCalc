package com.itMentor;

import java.util.Scanner;

// Тестовое задание Сущенко Алексея Сергеевича
// Осторожно, вызывает кровь из глаз
public class TestCalc {
    public static void main(String[] args) {

        String input = getString(); //инициализируем переменную строкой, полученной из консоли методом гетстринг.
        // и эта переменная отправляется в обработку метода calc
        System.out.println(calc(input)); //выводим на консоль полученное значение из метода calc
    }

    private static String getString() {
        //принимаем строку с консоли, и возвращаем ее в переменную input. Это я умею
        System.out.println("Введите арифметическое уравнение с двумя целыми числами от 0 до 10 \nПример: a+b, a-b, a*b, a/b");
        Scanner in = new Scanner(System.in);
        String input = in.nextLine();
        in.close();
        return input;
    }

    public static String calc(String input) {
        //тут вся магия, (с) Ьу методом тыка
        //сначала проверим, что введенная строка соответствует требованиям "число-мат.символ-число"
        try {
            if (input.matches("\\s*\\d{1,2}\\s*[+*/-]\\s*\\d{1,2}\\s*")) ;
                //эти регулярки сам построил
                //нагуглил про метод матчес, первый раз юзаю. Не забыть учесть возможные пробелы
            else throw new Exception("Ахтунг! Уравнение введено некорректно");
        } catch (Exception e) {

            System.out.println(e.getMessage());
            System.exit(0); // я хз правильно ли так завершать работу, но иначе она не прерывалась, решение тоже взял из гугла
        }
        //распихать содержимое строки по разным коробочкам
        String[] inc = input.split("[+*/-]"); //делим строку на числа с помощью регулярного выражения, найденного интернете, и пишем обрывки в массив
        // Не знаю, почему, но знак операции падает в индекс массива №1, а в 0 попадает пробел.
        String[] act = input.split("[^+*/-]+"); //делим строку на "математические символы" по символам "любой кроме перечисленных", и суем в массив

        int first = 0, second = 0; //оказывается, переменные нужно инициализировать до блока try, иначе они становятся локальными :Х
        try {
            //нагуглил магическое преобразование строки в число
            first = Integer.parseInt(inc[0].trim()); //иниц.перемнную int первым числом из массива строки
            second = Integer.parseInt(inc[1].trim()); //иниц. вторую переменную int
            //и проверим, что числа в заданных диапазонах от 0 до 10
            if (first < 0 || first > 10 || second < 0 || second > 10)
                throw new Exception("Ахтунг! Введено число вне диапазона 0-10");
            //сразу исключим деление на ноль
            if (second == 0 && act[1].equals("/")) throw new Exception("Ахтунг! Деление на нуль");
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
            System.exit(0);
        }

        //Определив, какой же знак математической операции мы получили из строки, произведем вычисление
        //Наверное это нужно было сделать через Enum, приложение будет более функциональным,
        // но сейчас мне кажется это написание двойного кода - на свичах связать полученные мат.символы с Константами,
        // а потом на свичах строить математику, и все это в отдельный метод засунуть. Я еще лох для этого.
        int result = 0;
        switch (act[1]) {
            case "+":
                result = first + second;
                break;
            case "-":
                result = first - second;
                break;
            case "*":
                result = first * second;
                break;
            case "/":
                result = first / second;
                break;
        }
        //очередное магическое преобразование числа в строку, из книги заклинаний гугл
        input = Integer.toString(result);

        return input;
    }
}